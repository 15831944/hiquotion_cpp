Self-Contained Container（自包含容器）

自包含容器是一种自包含的结构，很有趣。需要使用模板类，但只有在模板类型是该类的子类时，才使该类具有自包含的结构。这种结构从数据结构的角度看比较有用。通常的树类中的模板通常是“数据”的概念，即模板不参与树结构的逻辑，只作为树结点的一个额外的、附加的数据看待。但在自包含的树结点结构中，模板作为树结点的子类出现。

一、自包含树结点类

这样可以解决某种问题，即原来通常意义下的树结点类，如果子类实现了更多的功能，但子类的孩子结点却还是原来的树结点类。当然我们可以强制转换成树结点子类，但必须保证在添加孩子结点的时候都必须添加树结点子类，如果万一添加了树结点类，那么这种转换就不会成功，再操作就会有崩溃的风险。

那么就希望树结点子类的孩子节点仍然是树结点的子类。这样不存在类型强制转换，也就不存在转换失败的风险。这就是自包含树结点，即

template <class T>
class CSelfTreeNode
{
private:
	CPointerList<T> m_children;
}

当然，只有这个结构还构不成“自包含”，需要子类在继承的时候，模板类是他自己，即（假设子类名是 CDerivedSelfTreeNode）

class CDerivedSelfTreeNode : public CSelfTreeNode<DerivedSelfTreeNode *>
{

}

二、自包含列表结点

同时可以看到，如果我们把上面自包含树结点修改一下，就变成了一个自包含列表。好似将两个镜子相对，镜子里就会出现N多子镜子一样的效果。

template <class T>
class CSelfListNode
{
private:
	T m_t;
}

同样，我们需要子类的继承来实现自包含，即

class CDerivedSelfListNode : public CSelfListNode<CDerivedSelfListNode *>
{

}

三、自包含图结点和弧类

1、自包含图节点类

第一个模板参数用于自包含，即该模板参数是结点类的子类。第二个模板参数是弧类。

2、自包含图弧类

第一个模板参数也是用于自包含，即该模板参数是弧类的子类。第二个模板参数是结点类。


后记、一点点设想

突然有个想法，如果这种自包含的类结构用在分形理论的程序设计上，而不是用递归，是不是会带来一些意想不到的效果呢？（注：只是猜想，并没有实际去验证。）
